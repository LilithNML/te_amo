<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCrypto Secure Tool | WC01</title>
    <style>
        :root {
            --bg-color: #f4f6f8;
            --card-bg: #ffffff;
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --danger: #dc2626;
            --success: #16a34a;
            --text-main: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: var(--card-bg);
            width: 100%;
            max-width: 600px;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            display: flex;
            flex-direction: column;
        }

        h1 { margin-top: 0; font-size: 1.5rem; text-align: center; color: var(--text-main); }
        .subtitle { text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 2rem; }

        .tabs { display: flex; border-bottom: 2px solid var(--border); margin-bottom: 2rem; }
        .tab {
            flex: 1;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-muted);
            transition: all 0.2s;
        }
        .tab.active { color: var(--primary); border-bottom: 2px solid var(--primary); margin-bottom: -2px; }

        .form-group { margin-bottom: 1.5rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; }
        
        input[type="password"], input[type="file"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 1rem;
        }

        .btn {
            width: 100%;
            padding: 1rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn:hover { background-color: var(--primary-hover); }
        .btn:disabled { background-color: var(--text-muted); cursor: not-allowed; }

        .status-box {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 6px;
            display: none;
            font-size: 0.9rem;
        }
        .status-box.error { background-color: #fee2e2; color: var(--danger); border: 1px solid #fecaca; }
        .status-box.success { background-color: #dcfce7; color: var(--success); border: 1px solid #bbf7d0; }
        .status-box.info { background-color: #e0f2fe; color: var(--primary); border: 1px solid #bae6fd; }

        .download-link {
            display: block;
            margin-top: 1rem;
            text-align: center;
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
        }

        .hidden { display: none; }
        
        /* Security Warning Footer */
        .footer-note {
            margin-top: auto;
            padding-top: 2rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-align: center;
            border-top: 1px solid var(--border);
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Herramienta de Cifrado Local</h1>
    <p class="subtitle">AES-GCM 256-bit | PBKDF2 | WebCrypto API</p>

    <div class="tabs">
        <div class="tab active" onclick="switchTab('encrypt')">üîí Cifrar</div>
        <div class="tab" onclick="switchTab('decrypt')">üîì Descifrar</div>
    </div>

    <div id="encrypt-panel">
        <div class="form-group">
            <label>1. Selecciona el archivo</label>
            <input type="file" id="enc-file">
        </div>
        <div class="form-group">
            <label>2. Contrase√±a</label>
            <input type="password" id="enc-pass" placeholder="Ingresa una contrase√±a fuerte">
        </div>
        <div class="form-group">
            <label>3. Confirmar Contrase√±a</label>
            <input type="password" id="enc-pass-confirm" placeholder="Repite la contrase√±a">
        </div>
        <button class="btn" onclick="processEncryption()">Cifrar Archivo</button>
    </div>

    <div id="decrypt-panel" class="hidden">
        <div class="form-group">
            <label>1. Selecciona el archivo cifrado (.wenc)</label>
            <input type="file" id="dec-file">
        </div>
        <div class="form-group">
            <label>2. Contrase√±a</label>
            <input type="password" id="dec-pass" placeholder="Ingresa la contrase√±a de descifrado">
        </div>
        <button class="btn" onclick="processDecryption()">Descifrar Archivo</button>
    </div>

    <div id="status-area" class="status-box"></div>
    <a id="download-btn" class="download-link hidden">‚¨áÔ∏è Descargar Resultado</a>

    <div class="footer-note">
        ‚ö†Ô∏è <strong>Seguridad:</strong> Todo ocurre en tu navegador. Si pierdes la contrase√±a, el archivo es irrecuperable. No se env√≠a nada al servidor.
    </div>
</div>

<script>
    /**
     * CONSTANTES DE SEGURIDAD
     * WC01 = WebCrypto Versi√≥n 01
     */
    const MAGIC_BYTES = new Uint8Array([0x57, 0x43, 0x30, 0x31]); // "WC01"
    const PBKDF2_ITERATIONS = 150000;
    const SALT_LENGTH = 16; // Bytes
    const IV_LENGTH = 12;   // Bytes for AES-GCM
    const KEY_LENGTH = 256; // Bits

    // UI Switching
    function switchTab(mode) {
        document.getElementById('status-area').style.display = 'none';
        document.getElementById('download-btn').classList.add('hidden');
        
        if (mode === 'encrypt') {
            document.getElementById('encrypt-panel').classList.remove('hidden');
            document.getElementById('decrypt-panel').classList.add('hidden');
            document.querySelectorAll('.tab')[0].classList.add('active');
            document.querySelectorAll('.tab')[1].classList.remove('active');
        } else {
            document.getElementById('encrypt-panel').classList.add('hidden');
            document.getElementById('decrypt-panel').classList.remove('hidden');
            document.querySelectorAll('.tab')[0].classList.remove('active');
            document.querySelectorAll('.tab')[1].classList.add('active');
        }
    }

    // Logging UI
    function setStatus(msg, type = 'info') {
        const el = document.getElementById('status-area');
        el.textContent = msg;
        el.className = `status-box ${type}`;
        el.style.display = 'block';
    }

    /**
     * Genera material de clave desde el password (raw)
     */
    async function getPasswordKey(password) {
        const enc = new TextEncoder();
        return window.crypto.subtle.importKey(
            "raw",
            enc.encode(password),
            "PBKDF2",
            false,
            ["deriveKey"]
        );
    }

    /**
     * Deriva la clave AES-GCM usando PBKDF2
     */
    async function deriveKey(passwordKey, salt) {
        return window.crypto.subtle.deriveKey(
            {
                name: "PBKDF2",
                salt: salt,
                iterations: PBKDF2_ITERATIONS,
                hash: "SHA-256"
            },
            passwordKey,
            { name: "AES-GCM", length: KEY_LENGTH },
            false,
            ["encrypt", "decrypt"]
        );
    }

    /**
     * PROCESO DE CIFRADO
     */
    async function processEncryption() {
        const fileInput = document.getElementById('enc-file');
        const passInput = document.getElementById('enc-pass');
        const passConfInput = document.getElementById('enc-pass-confirm');
        const downloadLink = document.getElementById('download-btn');

        // Limpiar estado previo
        setStatus("Iniciando proceso...", "info");
        downloadLink.classList.add('hidden');

        // Validaciones
        if (!fileInput.files.length) return setStatus("Por favor selecciona un archivo.", "error");
        if (!passInput.value) return setStatus("La contrase√±a no puede estar vac√≠a.", "error");
        if (passInput.value !== passConfInput.value) return setStatus("Las contrase√±as no coinciden.", "error");
        if (passInput.value.length < 8) return setStatus("La contrase√±a es muy corta (min 8 caracteres).", "error");

        const file = fileInput.files[0];
        const password = passInput.value;

        try {
            setStatus("Leyendo archivo...", "info");
            const fileData = await file.arrayBuffer();

            setStatus("Generando par√°metros criptogr√°ficos...", "info");
            const salt = window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
            const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
            
            setStatus("Derivando clave (esto puede tardar unos segundos)...", "info");
            const passwordKey = await getPasswordKey(password);
            const aesKey = await deriveKey(passwordKey, salt);

            setStatus("Cifrando datos...", "info");
            const encryptedContent = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                aesKey,
                fileData
            );

            // Construir el archivo final: Magic + Salt + IV + Ciphertext
            setStatus("Empaquetando archivo...", "info");
            const finalBuffer = new Uint8Array(
                MAGIC_BYTES.length + salt.length + iv.length + encryptedContent.byteLength
            );
            
            finalBuffer.set(MAGIC_BYTES, 0);
            finalBuffer.set(salt, MAGIC_BYTES.length);
            finalBuffer.set(iv, MAGIC_BYTES.length + salt.length);
            finalBuffer.set(new Uint8Array(encryptedContent), MAGIC_BYTES.length + salt.length + iv.length);

            // Crear Blob
            const blob = new Blob([finalBuffer], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);

            // UI √âxito
            downloadLink.href = url;
            downloadLink.download = file.name + ".wenc";
            downloadLink.textContent = `‚¨áÔ∏è Descargar ${file.name}.wenc`;
            downloadLink.classList.remove('hidden');
            setStatus("¬°Archivo cifrado con √©xito!", "success");

            // Limpieza de memoria (best effort)
            passInput.value = "";
            passConfInput.value = "";

        } catch (err) {
            console.error(err);
            setStatus("Error durante el cifrado: " + err.message, "error");
        }
    }

    /**
     * PROCESO DE DESCIFRADO
     */
    async function processDecryption() {
        const fileInput = document.getElementById('dec-file');
        const passInput = document.getElementById('dec-pass');
        const downloadLink = document.getElementById('download-btn');

        setStatus("Iniciando proceso...", "info");
        downloadLink.classList.add('hidden');

        if (!fileInput.files.length) return setStatus("Selecciona un archivo .wenc", "error");
        if (!passInput.value) return setStatus("Ingresa la contrase√±a.", "error");

        const file = fileInput.files[0];
        const password = passInput.value;

        try {
            setStatus("Leyendo archivo...", "info");
            const fileData = await file.arrayBuffer();
            const dataView = new Uint8Array(fileData);

            // 1. Validar Magic Bytes
            setStatus("Validando formato...", "info");
            if (fileData.byteLength < (MAGIC_BYTES.length + SALT_LENGTH + IV_LENGTH)) {
                throw new Error("El archivo es demasiado peque√±o o inv√°lido.");
            }

            for (let i = 0; i < MAGIC_BYTES.length; i++) {
                if (dataView[i] !== MAGIC_BYTES[i]) {
                    throw new Error("Formato de archivo no reconocido (Faltan Magic Bytes WC01).");
                }
            }

            // 2. Extraer Salt y IV
            let offset = MAGIC_BYTES.length;
            const salt = dataView.slice(offset, offset + SALT_LENGTH);
            offset += SALT_LENGTH;
            const iv = dataView.slice(offset, offset + IV_LENGTH);
            offset += IV_LENGTH;
            const ciphertext = dataView.slice(offset);

            // 3. Derivar Clave
            setStatus("Derivando clave...", "info");
            const passwordKey = await getPasswordKey(password);
            const aesKey = await deriveKey(passwordKey, salt);

            // 4. Descifrar
            setStatus("Descifrando...", "info");
            const decryptedContent = await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv },
                aesKey,
                ciphertext
            );

            // Crear Blob para descarga
            const blob = new Blob([decryptedContent], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);

            // Intentar recuperar nombre original (quitando .wenc si existe)
            let originalName = file.name.replace(".wenc", "");
            if (originalName === file.name) originalName = "descifrado_" + file.name;

            downloadLink.href = url;
            downloadLink.download = originalName;
            downloadLink.textContent = `‚¨áÔ∏è Descargar ${originalName}`;
            downloadLink.classList.remove('hidden');
            setStatus("¬°Archivo descifrado correctamente!", "success");

            passInput.value = "";

        } catch (err) {
            console.error(err);
            if (err.name === "OperationError") {
                setStatus("Error: Contrase√±a incorrecta o archivo corrupto.", "error");
            } else {
                setStatus("Error: " + err.message, "error");
            }
        }
    }
</script>

</body>
</html>
